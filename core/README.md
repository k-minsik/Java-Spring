# 1. 예제 만들기
## 비지니스 요구사항과 설계
- 회원
  - 회원을 가입하고 조회할 수 있다
  - 회원은 일반과 VIP 두 가지 등급이 있다
  - 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다(미확정)
  

- 주문과 할인 정책
  - 회원은 상품을 주문할 수 있다.
  - 회원 등급에 따라 할인 정책을 적용할 수 있따.
  - 할인 정책은 모든 VIP는 1000월을 할인해주는 고정 금액 할인을 적용해달라(나중에 변경 될 수 있다)
  - 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다(미확정)
 
# 2. 객체 지향 원리 적용
## 새로운 할인 정책 개발

```
기획자: 서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라 좀
  더 합리적인 주문 금액당 할 인하는 정률% 할인으로 변경하고 싶어요.
  예를 들어서 기존 정책은 VIP가 10000원을 주문하든 20000원을 주 문하든 항상 1000원을 할인했는데,
  이번에 새로 나온 정책은 10%로 지정해두면 고객이 10000원 주문시 1000 원을 할인해주고,
  20000원 주문시에 2000원을 할인해주는 거에요!

개발자: 제가 처음부터 고정 금액 할인은 아니라고 했잖아요.

기획자: 애자일 소프트웨어 개발 선언 몰라요? “계획을 따르기보다 변화에 대응하기를”

개발자: ... (하지만 난 유연한 설계가 가능하도록 객체지향 설계 원칙을 준수했지 후후)"
```

# 3. 스프링 컨테이너와 스프링 빈
- ApplicationContext 를 스프링 컨테이너라 한다.
- 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.
- 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다.
- 여기서는 `AppConfig.class` 를 구성 정보로 지정했다.
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.
- 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입(DI)한다.


# 4. 싱글톤 컨테이너
- 웹 애플리케이션과 싱글톤
  - 순수한 DI 컨테이너인 AppConfig는 요청을 할 때 마다 객체를 새로 생성
  - 트래픽당 객체가 생성되고 소명된다 -> 메모리 낭비가 심하다
  - 해당 객체가, 공유하도록 설계하자 -> 싱글톤 패턴
- 싱글톤 패턴
  - 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
  - 객체 인스턴스를 2개 이상 생성하지 못하도록 설계
- 싱글톤 패턴 문제점
  - 구현 코드가 많다
  - 의존관계상 클라이언트가 구체 클래스에 의존 -> DIP 위반
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다
  - 테스트하기 어려움
  - 내부 속성을 변경하거나 초기화 하기 어렵다
  - private 생성자로 자식 클래스를 만들기 어렵다
  - 유연성이 떨어진다
  - 안티패턴으로 불리기도 한다
- 싱글톤 컨테이너
  - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
  - 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
  - 스프링 컨테이너의 이런 기능 덕에 싱글톤 패턴의 모든 단점을 해결하며 객체를 싱글톤으로 유지할 수 있다.
- 싱글톤 방식의 주의점
  - 싱글톤 방식은 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
  - 무상태(stateless)로 설계해야 한다
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
    - 가급적 읽기만 가능해야 한다.
    - 필드 대신 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

- Configuration과 바이트코드 조작
  -  스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용
  -  스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다 른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것
  -  @Configuration 을 적용하지 않고, @Bean 만 적용하면, AppConfig가 CGLIB 기술 없이 순수한 AppConfig로 스프링 빈에 등록

# 5. 컴포넌트 스캔
- 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 `컴포넌트 스캔`기능 제공
- 의존관계도 자동으로 주입하는 `@Autowired` 기능 제공
- `@ComponentScan` 은 `@Component` 가 붙은 모든 클래스를 스프링 빈으로 등록
  - 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용
- `@Autowired` 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입
- 스캔 대상
  - `@Component`, `@Controller`, `@Service`, `@Repository`, `@Configuration`
- 필터
  - `includeFilters` : 컴포넌트 스캔 대상을 추가로 지정
  - `excludeFilters` : 컴포넌트 스캔에서 제외할 대상을 지정
- 중복 등록과 충돌
  - 자동 빈 등록 vs 자동
    - `ConflictingBeanDefinitionException` 예외 발생
  - 수동 빈 등록 vs 자동
    - 수동 빈이 자동 빈을 오버라이딩 해서 우선권을 가짐
    - 최신 버젼은 일단 오류를 내지만 설정 변경으로 오버라이딩 할수 있음


# 6. 의존관계 자동 주입
- 생성자 주입
  - 생성자 호출시점에 딱 1번만 호출되는 것이 보장
  - 불변, 필수 의존관계에 사용
  - ** 생성자가 1개만 있으면 `@Autowired` 생략해도 자동 주입. 스프링 빈에만 해당 **
- 수정자 주입 (setter 주입)
  - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입
  - 선택, 변경 가능성이 있는 의존관계에 사용
  - 자바 빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법
- 필드 주입
  - 코드가 간단해서 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있음
  - DI 프레임워크가 없으면 아무것도 할 수 없다
  - `사용하지 말자`
- 일반 메서드 주입
  - 한번에 여러 필드를 주입 받을 수 있다.
  - 일반적으로 잘 사용하지 않는다
  > p v setXxx(M m, D d) == p v init(M m, D d)
- 옵션 처리
  - 주입할 스프링 빈이 없어도 동작해야 할 떄가 있다.
  - `@Autowired(required=false)` : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
  - `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 null이 입력된다. 
  - `Optional<>` : 자동 주입할 대상이 없으면 `Optional.empty` 가 입력된다.

- 생성자 주입을 선택해라
  - 대부분의 의존관계는 애플리케이션 종료 전 까지 변하면 안된다.(불변해야 한다)
  - 생성자 주입은 객체를 생성할 떄 한 번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할수 있다

- 롬복과 최신 트랜드
  - `Getter`, `Setter`
  - `ToString`
  - `RequiredArgsConstructor`

- 조회 빈이 2개 이상 - 문제
  - DiscountPolicy 하위 타입인 `FixDiscountPolicy`, `RateDiscountPolicy` 둘 다 스프링 빈으로 선언 하고 의존관계 자동 주입을 하면 오류발생
    - 이 때, 하위 타입으로 지정할 수 잇지만, DIP를 위배하고 유연성이 떨어짐. 그리고 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결 불가
  - `@Qualifier("beanName")` 주입시에 붙여주고 등록한 이름을 적어준다
  - `@Primary`
  - `@Qualifier` 가 `@Primary` 보다 우선 순위가 높다
- 애노테이션 직접 만들기  

- 조회한 빈이 모두 필요할 때, List, Map

- 자동, 수동의 올바른 실무 운영 기준
  - 편리한 자동 기능을 기본으로 사용하자
  - 자동 빈으로 OCP, DIP를 지킬 수 있다
  - 기술 지원 빈에서는 수동이 유지보수에 좋다
  - 비지니스 로직 중에서 다형성을 적극 활용할 때에
    - 이런 경우 수동 빈으로 등록하거나 또는 자동으로하면 특정 패키지에 같이 묶어 두는게 좋다
